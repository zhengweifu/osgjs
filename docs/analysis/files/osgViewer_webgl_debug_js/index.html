<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>osgViewer/webgl-debug.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">64.66</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">934</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">76.15</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">6.17</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* jshint ignore:start */

define( [], function () {

    //Copyright (c) 2009 The Chromium Authors. All rights reserved.
    //Use of this source code is governed by a BSD-style license that can be
    //found in the LICENSE file.

    // Various functions for helping debug WebGL apps.

    var WebGLDebugUtils = function () {

        /**
         * Wrapped logging function.
         * @param {string} msg Message to log.
         */
        var log = function ( msg ) {
            if ( window.console &amp;&amp; window.console.log ) {
                window.console.log( msg );
            }
        };

        /**
         * Which arguements are enums.
         * @type {!Object.&lt;number, string&gt;}
         */
        var glValidEnumContexts = {

            // Generic setters and getters

            &#039;enable&#039;: {
                0: true
            },
            &#039;disable&#039;: {
                0: true
            },
            &#039;getParameter&#039;: {
                0: true
            },

            // Rendering

            &#039;drawArrays&#039;: {
                0: true
            },
            &#039;drawElements&#039;: {
                0: true,
                2: true
            },

            // Shaders

            &#039;createShader&#039;: {
                0: true
            },
            &#039;getShaderParameter&#039;: {
                1: true
            },
            &#039;getProgramParameter&#039;: {
                1: true
            },

            // Vertex attributes

            &#039;getVertexAttrib&#039;: {
                1: true
            },
            &#039;vertexAttribPointer&#039;: {
                2: true
            },

            // Textures

            &#039;bindTexture&#039;: {
                0: true
            },
            &#039;activeTexture&#039;: {
                0: true
            },
            &#039;getTexParameter&#039;: {
                0: true,
                1: true
            },
            &#039;texParameterf&#039;: {
                0: true,
                1: true
            },
            &#039;texParameteri&#039;: {
                0: true,
                1: true,
                2: true
            },
            &#039;texImage2D&#039;: {
                0: true,
                2: true,
                6: true,
                7: true
            },
            &#039;texSubImage2D&#039;: {
                0: true,
                6: true,
                7: true
            },
            &#039;copyTexImage2D&#039;: {
                0: true,
                2: true
            },
            &#039;copyTexSubImage2D&#039;: {
                0: true
            },
            &#039;generateMipmap&#039;: {
                0: true
            },

            // Buffer objects

            &#039;bindBuffer&#039;: {
                0: true
            },
            &#039;bufferData&#039;: {
                0: true,
                2: true
            },
            &#039;bufferSubData&#039;: {
                0: true
            },
            &#039;getBufferParameter&#039;: {
                0: true,
                1: true
            },

            // Renderbuffers and framebuffers

            &#039;pixelStorei&#039;: {
                0: true,
                1: true
            },
            &#039;readPixels&#039;: {
                4: true,
                5: true
            },
            &#039;bindRenderbuffer&#039;: {
                0: true
            },
            &#039;bindFramebuffer&#039;: {
                0: true
            },
            &#039;checkFramebufferStatus&#039;: {
                0: true
            },
            &#039;framebufferRenderbuffer&#039;: {
                0: true,
                1: true,
                2: true
            },
            &#039;framebufferTexture2D&#039;: {
                0: true,
                1: true,
                2: true
            },
            &#039;getFramebufferAttachmentParameter&#039;: {
                0: true,
                1: true,
                2: true
            },
            &#039;getRenderbufferParameter&#039;: {
                0: true,
                1: true
            },
            &#039;renderbufferStorage&#039;: {
                0: true,
                1: true
            },

            // Frame buffer operations (clear, blend, depth test, stencil)

            &#039;clear&#039;: {
                0: true
            },
            &#039;depthFunc&#039;: {
                0: true
            },
            &#039;blendFunc&#039;: {
                0: true,
                1: true
            },
            &#039;blendFuncSeparate&#039;: {
                0: true,
                1: true,
                2: true,
                3: true
            },
            &#039;blendEquation&#039;: {
                0: true
            },
            &#039;blendEquationSeparate&#039;: {
                0: true,
                1: true
            },
            &#039;stencilFunc&#039;: {
                0: true
            },
            &#039;stencilFuncSeparate&#039;: {
                0: true,
                1: true
            },
            &#039;stencilMaskSeparate&#039;: {
                0: true
            },
            &#039;stencilOp&#039;: {
                0: true,
                1: true,
                2: true
            },
            &#039;stencilOpSeparate&#039;: {
                0: true,
                1: true,
                2: true,
                3: true
            },

            // Culling

            &#039;cullFace&#039;: {
                0: true
            },
            &#039;frontFace&#039;: {
                0: true
            }
        };

        /**
         * Map of numbers to names.
         * @type {Object}
         */
        var glEnums = null;

        /**
         * Initializes this module. Safe to call more than once.
         * @param {!WebGLRenderingContext} ctx A WebGL context. If
         *    you have more than one context it doesn&#039;t matter which one
         *    you pass in, it is only used to pull out constants.
         */
        function init( ctx ) {
            if ( glEnums === null ) {
                glEnums = {};
                for ( var propertyName in ctx ) {
                    if ( typeof ctx[ propertyName ] === &#039;number&#039; ) {
                        glEnums[ ctx[ propertyName ] ] = propertyName;
                    }
                }
            }
        }

        /**
         * Checks the utils have been initialized.
         */
        function checkInit() {
            if ( glEnums === null ) {
                throw &#039;WebGLDebugUtils.init(ctx) not called&#039;;
            }
        }

        /**
         * Returns true or false if value matches any WebGL enum
         * @param {*} value Value to check if it might be an enum.
         * @return {boolean} True if value matches one of the WebGL defined enums
         */
        function mightBeEnum( value ) {
            checkInit();
            return ( glEnums[ value ] !== undefined );
        }

        /**
         * Gets an string version of an WebGL enum.
         *
         * Example:
         *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
         *
         * @param {number} value Value to return an enum for
         * @return {string} The string version of the enum.
         */
        function glEnumToString( value ) {
            checkInit();
            var name = glEnums[ value ];
            return ( name !== undefined ) ? name :
                ( &#039;*UNKNOWN WebGL ENUM (0x&#039; + value.toString( 16 ) + &#039;)&#039; );
        }

        /**
         * Returns the string version of a WebGL argument.
         * Attempts to convert enum arguments to strings.
         * @param {string} functionName the name of the WebGL function.
         * @param {number} argumentIndx the index of the argument.
         * @param {*} value The value of the argument.
         * @return {string} The value as a string.
         */
        function glFunctionArgToString( functionName, argumentIndex, value ) {
            var funcInfo = glValidEnumContexts[ functionName ];
            if ( funcInfo !== undefined ) {
                if ( funcInfo[ argumentIndex ] ) {
                    return glEnumToString( value );
                }
            }
            return value.toString();
        }

        function makePropertyWrapper( wrapper, original, propertyName ) {
            //log(&quot;wrap prop: &quot; + propertyName);
            wrapper.__defineGetter__( propertyName, function () {
                return original[ propertyName ];
            } );
            // TODO(gmane): this needs to handle properties that take more than
            // one value?
            wrapper.__defineSetter__( propertyName, function ( value ) {
                //log(&quot;set: &quot; + propertyName);
                original[ propertyName ] = value;
            } );
        }

        // Makes a function that calls a function on another object.
        function makeFunctionWrapper( original, functionName ) {
            //log(&quot;wrap fn: &quot; + functionName);
            var f = original[ functionName ];
            return function () {
                //log(&quot;call: &quot; + functionName);
                var result = f.apply( original, arguments );
                return result;
            };
        }

        /**
         * Given a WebGL context returns a wrapped context that calls
         * gl.getError after every command and calls a function if the
         * result is not gl.NO_ERROR.
         *
         * @param {!WebGLRenderingContext} ctx The webgl context to
         *        wrap.
         * @param {!function(err, funcName, args): void} opt_onErrorFunc
         *        The function to call when gl.getError returns an
         *        error. If not specified the default function calls
         *        console.log with a message.
         */
        function makeDebugContext( ctx, opt_onErrorFunc ) {
            init( ctx );
            opt_onErrorFunc = opt_onErrorFunc || function ( err, functionName, args ) {
                // apparently we can&#039;t do args.join(&quot;,&quot;);
                var argStr = &quot;&quot;;
                for ( var ii = 0; ii &lt; args.length; ++ii ) {
                    argStr += ( ( ii === 0 ) ? &#039;&#039; : &#039;, &#039; ) +
                        glFunctionArgToString( functionName, ii, args[ ii ] );
                }
                log( &quot;WebGL error &quot; + glEnumToString( err ) + &quot; in &quot; + functionName +
                    &quot;(&quot; + argStr + &quot;)&quot; );
            };

            // Holds booleans for each GL error so after we get the error ourselves
            // we can still return it to the client app.
            var glErrorShadow = {};

            // Makes a function that calls a WebGL function and then calls getError.
            function makeErrorWrapper( ctx, functionName ) {
                return function () {
                    var result = ctx[ functionName ].apply( ctx, arguments );
                    var err = ctx.getError();
                    if ( err !== 0 ) {
                        glErrorShadow[ err ] = true;
                        opt_onErrorFunc( err, functionName, arguments );
                    }
                    return result;
                };
            }

            // Make a an object that has a copy of every property of the WebGL context
            // but wraps all functions.
            var wrapper = {};
            for ( var propertyName in ctx ) {
                if ( typeof ctx[ propertyName ] == &#039;function&#039; ) {
                    wrapper[ propertyName ] = makeErrorWrapper( ctx, propertyName );
                } else {
                    makePropertyWrapper( wrapper, ctx, propertyName );
                }
            }

            // Override the getError function with one that returns our saved results.
            wrapper.getError = function () {
                for ( var err in glErrorShadow ) {
                    if ( glErrorShadow[ err ] ) {
                        glErrorShadow[ err ] = false;
                        return err;
                    }
                }
                return ctx.NO_ERROR;
            };

            return wrapper;
        }

        function resetToInitialState( ctx ) {
            var numAttribs = ctx.getParameter( ctx.MAX_VERTEX_ATTRIBS );
            var tmp = ctx.createBuffer();
            ctx.bindBuffer( ctx.ARRAY_BUFFER, tmp );
            var ii;
            for ( ii = 0; ii &lt; numAttribs; ++ii ) {
                ctx.disableVertexAttribArray( ii );
                ctx.vertexAttribPointer( ii, 4, ctx.FLOAT, false, 0, 0 );
                ctx.vertexAttrib1f( ii, 0 );
            }
            ctx.deleteBuffer( tmp );

            var numTextureUnits = ctx.getParameter( ctx.MAX_TEXTURE_IMAGE_UNITS );
            for ( ii = 0; ii &lt; numTextureUnits; ++ii ) {
                ctx.activeTexture( ctx.TEXTURE0 + ii );
                ctx.bindTexture( ctx.TEXTURE_CUBE_MAP, null );
                ctx.bindTexture( ctx.TEXTURE_2D, null );
            }

            ctx.activeTexture( ctx.TEXTURE0 );
            ctx.useProgram( null );
            ctx.bindBuffer( ctx.ARRAY_BUFFER, null );
            ctx.bindBuffer( ctx.ELEMENT_ARRAY_BUFFER, null );
            ctx.bindFramebuffer( ctx.FRAMEBUFFER, null );
            ctx.bindRenderbuffer( ctx.RENDERBUFFER, null );
            ctx.disable( ctx.BLEND );
            ctx.disable( ctx.CULL_FACE );
            ctx.disable( ctx.DEPTH_TEST );
            ctx.disable( ctx.DITHER );
            ctx.disable( ctx.SCISSOR_TEST );
            ctx.blendColor( 0, 0, 0, 0 );
            ctx.blendEquation( ctx.FUNC_ADD );
            ctx.blendFunc( ctx.ONE, ctx.ZERO );
            ctx.clearColor( 0, 0, 0, 0 );
            ctx.clearDepth( 1 );
            ctx.clearStencil( -1 );
            ctx.colorMask( true, true, true, true );
            ctx.cullFace( ctx.BACK );
            ctx.depthFunc( ctx.LESS );
            ctx.depthMask( true );
            ctx.depthRange( 0, 1 );
            ctx.frontFace( ctx.CCW );
            ctx.hint( ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE );
            ctx.lineWidth( 1 );
            ctx.pixelStorei( ctx.PACK_ALIGNMENT, 4 );
            ctx.pixelStorei( ctx.UNPACK_ALIGNMENT, 4 );
            ctx.pixelStorei( ctx.UNPACK_FLIP_Y_WEBGL, false );
            ctx.pixelStorei( ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );
            // TODO: Delete this IF.
            if ( ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL ) {
                ctx.pixelStorei( ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL );
            }
            ctx.polygonOffset( 0, 0 );
            ctx.sampleCoverage( 1, false );
            ctx.scissor( 0, 0, ctx.canvas.width, ctx.canvas.height );
            ctx.stencilFunc( ctx.ALWAYS, 0, 0xFFFFFFFF );
            ctx.stencilMask( 0xFFFFFFFF );
            ctx.stencilOp( ctx.KEEP, ctx.KEEP, ctx.KEEP );
            ctx.viewport( 0, 0, ctx.canvas.width, ctx.canvas.height );
            ctx.clear( ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT );

            // TODO: This should NOT be needed but Firefox fails with &#039;hint&#039;
            while ( ctx.getError() ) {}
        }

        function makeLostContextSimulatingCanvas( canvas ) {
            var unwrappedContext_;
            //var wrappedContext_;
            var onLost_ = [];
            var onRestored_ = [];
            var wrappedContext_ = {};
            var contextId_ = 1;
            var contextLost_ = false;
            var resourceId_ = 0;
            var resourceDb_ = [];
            var numCallsToLoseContext_ = 0;
            var numCalls_ = 0;
            var canRestore_ = false;
            var restoreTimeout_ = 0;

            // Holds booleans for each GL error so can simulate errors.
            var glErrorShadow_ = {};

            canvas.getContext = function ( f ) {
                return function () {
                    var ctx = f.apply( canvas, arguments );
                    // Did we get a context and is it a WebGL context?
                    if ( ctx instanceof WebGLRenderingContext ) {
                        if ( ctx != unwrappedContext_ ) {
                            if ( unwrappedContext_ ) {
                                throw &quot;got different context&quot;;
                            }
                            unwrappedContext_ = ctx;
                            wrappedContext_ = makeLostContextSimulatingContext( unwrappedContext_ );
                        }
                        return wrappedContext_;
                    }
                    return ctx;
                };
            }( canvas.getContext );

            function wrapEvent( listener ) {
                if ( typeof ( listener ) == &quot;function&quot; ) {
                    return listener;
                } else {
                    return function ( info ) {
                        listener.handleEvent( info );
                    };
                }
            }

            var addOnContextLostListener = function ( listener ) {
                onLost_.push( wrapEvent( listener ) );
            };

            var addOnContextRestoredListener = function ( listener ) {
                onRestored_.push( wrapEvent( listener ) );
            };


            function wrapAddEventListener( canvas ) {
                var f = canvas.addEventListener;
                canvas.addEventListener = function ( type, listener, bubble ) {
                    switch ( type ) {
                    case &#039;webglcontextlost&#039;:
                        addOnContextLostListener( listener );
                        break;
                    case &#039;webglcontextrestored&#039;:
                        addOnContextRestoredListener( listener );
                        break;
                    default:
                        f.apply( canvas, arguments );
                    }
                };
            }

            wrapAddEventListener( canvas );

            canvas.loseContext = function () {
                if ( !contextLost_ ) {
                    contextLost_ = true;
                    numCallsToLoseContext_ = 0;
                    ++contextId_;
                    while ( unwrappedContext_.getError() ) {}
                    clearErrors();
                    glErrorShadow_[ unwrappedContext_.CONTEXT_LOST_WEBGL ] = true;
                    var event = makeWebGLContextEvent( &quot;context lost&quot; );
                    var callbacks = onLost_.slice();
                    setTimeout( function () {
                        //log(&quot;numCallbacks:&quot; + callbacks.length);
                        for ( var ii = 0; ii &lt; callbacks.length; ++ii ) {
                            //log(&quot;calling callback:&quot; + ii);
                            callbacks[ ii ]( event );
                        }
                        if ( restoreTimeout_ &gt;= 0 ) {
                            setTimeout( function () {
                                canvas.restoreContext();
                            }, restoreTimeout_ );
                        }
                    }, 0 );
                }
            };

            canvas.restoreContext = function () {
                if ( contextLost_ ) {
                    if ( onRestored_.length ) {
                        setTimeout( function () {
                            if ( !canRestore_ ) {
                                throw &quot;can not restore. webglcontestlost listener did not call event.preventDefault&quot;;
                            }
                            freeResources();
                            resetToInitialState( unwrappedContext_ );
                            contextLost_ = false;
                            numCalls_ = 0;
                            canRestore_ = false;
                            var callbacks = onRestored_.slice();
                            var event = makeWebGLContextEvent( &quot;context restored&quot; );
                            for ( var ii = 0; ii &lt; callbacks.length; ++ii ) {
                                callbacks[ ii ]( event );
                            }
                        }, 0 );
                    }
                }
            };

            canvas.loseContextInNCalls = function ( numCalls ) {
                if ( contextLost_ ) {
                    throw &quot;You can not ask a lost contet to be lost&quot;;
                }
                numCallsToLoseContext_ = numCalls_ + numCalls;
            };

            canvas.getNumCalls = function () {
                return numCalls_;
            };

            canvas.setRestoreTimeout = function ( timeout ) {
                restoreTimeout_ = timeout;
            };

            function isWebGLObject( obj ) {
                //return false;
                return ( obj instanceof WebGLBuffer ||
                    obj instanceof WebGLFramebuffer ||
                    obj instanceof WebGLProgram ||
                    obj instanceof WebGLRenderbuffer ||
                    obj instanceof WebGLShader ||
                    obj instanceof WebGLTexture );
            }

            function checkResources( args ) {
                for ( var ii = 0; ii &lt; args.length; ++ii ) {
                    var arg = args[ ii ];
                    if ( isWebGLObject( arg ) ) {
                        return arg.__webglDebugContextLostId__ == contextId_;
                    }
                }
                return true;
            }

            function clearErrors() {
                var k = Object.keys( glErrorShadow_ );
                for ( var ii = 0; ii &lt; k.length; ++ii ) {
                    delete glErrorShadow_[ k ];
                }
            }

            function loseContextIfTime() {
                ++numCalls_;
                if ( !contextLost_ ) {
                    if ( numCallsToLoseContext_ == numCalls_ ) {
                        canvas.loseContext();
                    }
                }
            }

            // Makes a function that simulates WebGL when out of context.
            function makeLostContextFunctionWrapper( ctx, functionName ) {
                var f = ctx[ functionName ];
                return function () {
                    // log(&quot;calling:&quot; + functionName);
                    // Only call the functions if the context is not lost.
                    loseContextIfTime();
                    if ( !contextLost_ ) {
                        //if (!checkResources(arguments)) {
                        //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;
                        //  return;
                        //}
                        var result = f.apply( ctx, arguments );
                        return result;
                    }
                };
            }

            function freeResources() {
                for ( var ii = 0; ii &lt; resourceDb_.length; ++ii ) {
                    var resource = resourceDb_[ ii ];
                    if ( resource instanceof WebGLBuffer ) {
                        unwrappedContext_.deleteBuffer( resource );
                    } else if ( resource instanceof WebGLFramebuffer ) {
                        unwrappedContext_.deleteFramebuffer( resource );
                    } else if ( resource instanceof WebGLProgram ) {
                        unwrappedContext_.deleteProgram( resource );
                    } else if ( resource instanceof WebGLRenderbuffer ) {
                        unwrappedContext_.deleteRenderbuffer( resource );
                    } else if ( resource instanceof WebGLShader ) {
                        unwrappedContext_.deleteShader( resource );
                    } else if ( resource instanceof WebGLTexture ) {
                        unwrappedContext_.deleteTexture( resource );
                    }
                }
            }

            function makeWebGLContextEvent( statusMessage ) {
                return {
                    statusMessage: statusMessage,
                    preventDefault: function () {
                        canRestore_ = true;
                    }
                };
            }


            function makeLostContextSimulatingContext( ctx ) {
                // copy all functions and properties to wrapper
                for ( var propertyName in ctx ) {
                    if ( typeof ctx[ propertyName ] == &#039;function&#039; ) {
                        wrappedContext_[ propertyName ] = makeLostContextFunctionWrapper(
                            ctx, propertyName );
                    } else {
                        makePropertyWrapper( wrappedContext_, ctx, propertyName );
                    }
                }

                // Wrap a few functions specially.
                wrappedContext_.getError = function () {
                    loseContextIfTime();
                    var err;
                    if ( !contextLost_ ) {
                        while ( err = unwrappedContext_.getError() ) {
                            glErrorShadow_[ err ] = true;
                        }
                    }
                    for ( err in glErrorShadow_ ) {
                        if ( glErrorShadow_[ err ] ) {
                            delete glErrorShadow_[ err ];
                            return err;
                        }
                    }
                    return wrappedContext_.NO_ERROR;
                };

                var creationFunctions = [
                    &quot;createBuffer&quot;,
                    &quot;createFramebuffer&quot;,
                    &quot;createProgram&quot;,
                    &quot;createRenderbuffer&quot;,
                    &quot;createShader&quot;,
                    &quot;createTexture&quot;
                ];
                var functionName, ii;
                for ( ii = 0; ii &lt; creationFunctions.length; ++ii ) {
                    functionName = creationFunctions[ ii ];
                    wrappedContext_[ functionName ] = function ( f ) {
                        return function () {
                            loseContextIfTime();
                            if ( contextLost_ ) {
                                return null;
                            }
                            var obj = f.apply( ctx, arguments );
                            obj.__webglDebugContextLostId__ = contextId_;
                            resourceDb_.push( obj );
                            return obj;
                        };
                    }( ctx[ functionName ] );
                }

                var functionsThatShouldReturnNull = [
                    &quot;getActiveAttrib&quot;,
                    &quot;getActiveUniform&quot;,
                    &quot;getBufferParameter&quot;,
                    &quot;getContextAttributes&quot;,
                    &quot;getAttachedShaders&quot;,
                    &quot;getFramebufferAttachmentParameter&quot;,
                    &quot;getParameter&quot;,
                    &quot;getProgramParameter&quot;,
                    &quot;getProgramInfoLog&quot;,
                    &quot;getRenderbufferParameter&quot;,
                    &quot;getShaderParameter&quot;,
                    &quot;getShaderInfoLog&quot;,
                    &quot;getShaderSource&quot;,
                    &quot;getTexParameter&quot;,
                    &quot;getUniform&quot;,
                    &quot;getUniformLocation&quot;,
                    &quot;getVertexAttrib&quot;
                ];
                for ( ii = 0; ii &lt; functionsThatShouldReturnNull.length; ++ii ) {
                    functionName = functionsThatShouldReturnNull[ ii ];
                    wrappedContext_[ functionName ] = function ( f ) {
                        return function () {
                            loseContextIfTime();
                            if ( contextLost_ ) {
                                return null;
                            }
                            return f.apply( ctx, arguments );
                        };
                    }( wrappedContext_[ functionName ] );
                }

                var isFunctions = [
                    &quot;isBuffer&quot;,
                    &quot;isEnabled&quot;,
                    &quot;isFramebuffer&quot;,
                    &quot;isProgram&quot;,
                    &quot;isRenderbuffer&quot;,
                    &quot;isShader&quot;,
                    &quot;isTexture&quot;
                ];
                for ( ii = 0; ii &lt; isFunctions.length; ++ii ) {
                    functionName = isFunctions[ ii ];
                    wrappedContext_[ functionName ] = function ( f ) {
                        return function () {
                            loseContextIfTime();
                            if ( contextLost_ ) {
                                return false;
                            }
                            return f.apply( ctx, arguments );
                        };
                    }( wrappedContext_[ functionName ] );
                }

                wrappedContext_.checkFramebufferStatus = function ( f ) {
                    return function () {
                        loseContextIfTime();
                        if ( contextLost_ ) {
                            return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;
                        }
                        return f.apply( ctx, arguments );
                    };
                }( wrappedContext_.checkFramebufferStatus );

                wrappedContext_.getAttribLocation = function ( f ) {
                    return function () {
                        loseContextIfTime();
                        if ( contextLost_ ) {
                            return -1;
                        }
                        return f.apply( ctx, arguments );
                    };
                }( wrappedContext_.getAttribLocation );

                wrappedContext_.getVertexAttribOffset = function ( f ) {
                    return function () {
                        loseContextIfTime();
                        if ( contextLost_ ) {
                            return 0;
                        }
                        return f.apply( ctx, arguments );
                    };
                }( wrappedContext_.getVertexAttribOffset );

                wrappedContext_.isContextLost = function () {
                    return contextLost_;
                };

                return wrappedContext_;
            }

            // TODO: find why this is there ?
            return canvas;
        }

        return {
            /**
     * Initializes this module. Safe to call more than once.
     * @param {!WebGLRenderingContext} ctx A WebGL context. If
    }
   *    you have more than one context it doesn&#039;t matter which one
   *    you pass in, it is only used to pull out constants.
   */
            &#039;init&#039;: init,

            /**
             * Returns true or false if value matches any WebGL enum
             * @param {*} value Value to check if it might be an enum.
             * @return {boolean} True if value matches one of the WebGL defined enums
             */
            &#039;mightBeEnum&#039;: mightBeEnum,

            /**
             * Gets an string version of an WebGL enum.
             *
             * Example:
             *   WebGLDebugUtil.init(ctx);
             *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
             *
             * @param {number} value Value to return an enum for
             * @return {string} The string version of the enum.
             */
            &#039;glEnumToString&#039;: glEnumToString,

            /**
             * Converts the argument of a WebGL function to a string.
             * Attempts to convert enum arguments to strings.
             *
             * Example:
             *   WebGLDebugUtil.init(ctx);
             *   var str = WebGLDebugUtil.glFunctionArgToString(&#039;bindTexture&#039;, 0, gl.TEXTURE_2D);
             *
             * would return &#039;TEXTURE_2D&#039;
             *
             * @param {string} functionName the name of the WebGL function.
             * @param {number} argumentIndx the index of the argument.
             * @param {*} value The value of the argument.
             * @return {string} The value as a string.
             */
            &#039;glFunctionArgToString&#039;: glFunctionArgToString,

            /**
             * Given a WebGL context returns a wrapped context that calls
             * gl.getError after every command and calls a function if the
             * result is not NO_ERROR.
             *
             * You can supply your own function if you want. For example, if you&#039;d like
             * an exception thrown on any GL error you could do this
             *
             *    function throwOnGLError(err, funcName, args) {
             *      throw WebGLDebugUtils.glEnumToString(err) + &quot; was caused by call to&quot; +
             *            funcName;
             *    };
             *
             *    ctx = WebGLDebugUtils.makeDebugContext(
             *        canvas.getContext(&quot;webgl&quot;), throwOnGLError);
             *
             * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
             * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
             *     to call when gl.getError returns an error. If not specified the default
             *     function calls console.log with a message.
             */
            &#039;makeDebugContext&#039;: makeDebugContext,

            /**
             * Given a canvas element returns a wrapped canvas element that will
             * simulate lost context. The canvas returned adds the following functions.
             *
             * loseContext:
             *   simulates a lost context event.
             *
             * restoreContext:
             *   simulates the context being restored.
             *
             * lostContextInNCalls:
             *   loses the context after N gl calls.
             *
             * getNumCalls:
             *   tells you how many gl calls there have been so far.
             *
             * setRestoreTimeout:
             *   sets the number of milliseconds until the context is restored
             *   after it has been lost. Defaults to 0. Pass -1 to prevent
             *   automatic restoring.
             *
             * @param {!Canvas} canvas The canvas element to wrap.
             */
            &#039;makeLostContextSimulatingCanvas&#039;: makeLostContextSimulatingCanvas,

            /**
             * Resets a context to the initial state.
             * @param {!WebGLRenderingContext} ctx The webgl context to
             *     reset.
             */
            &#039;resetToInitialState&#039;: resetToInitialState
        };

    }();

    return WebGLDebugUtils;
} );

/* jshint ignore:end */</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
